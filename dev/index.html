<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ODBC.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ODBC.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Getting-Started-1">Getting Started</a></li><li><a class="toctext" href="#Troubleshooting-1">Troubleshooting</a></li><li><a class="toctext" href="#API-Reference-1">API Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaDatabases/ODBC.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ODBC.jl-1" href="#ODBC.jl-1">ODBC.jl</a></h1><ul><li><a href="#ODBC.jl-1">ODBC.jl</a></li><ul><li><a href="#Getting-Started-1">Getting Started</a></li><ul><li><a href="#Connections-1">Connections</a></li><li><a href="#Executing-Queries-1">Executing Queries</a></li><li><a href="#Loading-data-1">Loading data</a></li></ul><li><a href="#Troubleshooting-1">Troubleshooting</a></li><ul><li><a href="#Connection-issues-1">Connection issues</a></li><li><a href="#Query-mangling/unicode-issues-1">Query mangling/unicode issues</a></li></ul><li><a href="#API-Reference-1">API Reference</a></li><ul><li><a href="#DBMS-Connections-1">DBMS Connections</a></li><li><a href="#Query-execution-and-result-handling-1">Query execution and result handling</a></li><li><a href="#Data-loading-1">Data loading</a></li><li><a href="#ODBC-administrative-functions-1">ODBC administrative functions</a></li></ul></ul></ul><p>The ODBC.jl package provides a Julia interface for the ODBC API as implemented by various ODBC driver managers. More specifically, it provides a prebuilt copy of iODBC and unixODBC for OSX/Linux platforms, while still relying on the system-provided libraries on Windows. This means that no extra installation of a driver manager is necessary after installing the ODBC.jl package like:</p><pre><code class="language-julia">] add ODBC</code></pre><p>Another common source of headache with ODBC is the various locations of configuration files on OSX/Linux; to remedy this, ODBC.jl writes and loads its own <code>odbc.ini</code> and <code>odbcinst.ini</code> configuration files inside the package directory, like <code>ODBC/config/odbc.ini</code>. This ensures ODBC enviornment variables like <code>ODBCINI</code> are correctly set to the ODBC.jl managed config files. Additionally, ODBC.jl provides convenient ODBC administrative functions to add/remove drivers and dsns (see <a href="@ref"><code>ODBC.addriver</code></a> and <a href="#ODBC.adddsn"><code>ODBC.adddsn</code></a>).</p><p>What this all means is that hopefully ODBC.jl provides the easiest setup experience possible for a slightly dated API that is known for configuration complexities.</p><h2><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h2><p>Once ODBC.jl is installed, you&#39;ll want, at a minimum, to configure ODBC drivers for the specific databases you&#39;ll be connecting to. A reminder on ODBC architecture that each database must build/distribute their own compliant ODBC driver that can talk with the ODBC.jl-provided driver manager to make connections, execute queries, etc. What&#39;s more, individual database drivers must often build against a specific driver manager (or specific driver manager per platform). By default, ODBC.jl will use iODBC as driver manager on OSX, unixODBC on Linux platforms, and the system-provided driver manager on Windows. If a database driver mentions a requirement for a specific driver manager, ODBC.jl provides a way to switch between them, even at run-time (see <a href="@ref"><code>ODBC.setiODBC</code></a> and <a href="@ref"><code>ODBC.setunixODBC</code></a>).</p><p>To install an ODBC driver, you can call:</p><pre><code class="language-julia">ODBC.adddriver(&quot;name of driver&quot;, &quot;full, absolute path to driver shared library&quot;; kw...)</code></pre><p>passing the name of the driver, the full, absolute path to the driver shared library, and any additional keyword arguments which will be included as <code>KEY=VALUE</code> pairs in the <code>.ini</code> config files. ***NOTE*** on Windows, you likely need to start Julia (or your terminal) with administrative privileges (like ctrl + right-click the application, then choose open as admin) in order to add drivers via ODBC like this.</p><h3><a class="nav-anchor" id="Connections-1" href="#Connections-1">Connections</a></h3><p>Once a driver or two are installed (viewable by calling <code>ODBC.drivers()</code>), you can either:</p><ul><li>Setup a DSN, via <code>ODBC.adddsn(&quot;dsn name&quot;, &quot;driver name&quot;; kw...)</code></li><li>Make a connection directly by using a full connection string like <code>ODBC.Connection(connection_string)</code></li></ul><p>In setting up a DSN, you can specify all the configuration options once, then connect by just calling <code>ODBC.Connection(&quot;dsn name&quot;)</code> or <code>DBInterface.execute(ODBC.Connection, &quot;dsn name&quot;)</code>, optionally passing a username and password as the 2nd and 3rd arguments. Alternatively, crafting and connecting via a fully specified connection string can mean less config-file dependency.</p><p>Note that connecting will use the currently &quot;set&quot; ODBC driver manager, which by default is iODBC on OSX, unixODBC on Linux, and the system driver manager on Windows. If you experience cryptic connection errors, it&#39;s probably worth checking with your ODBC driver documentation to see if it requires a specific driver manager. For example, Microsoft-provided ODBC driver for SQL Server requires unixODBC on OSX, but by default, ODBC.jl sets the driver manager to iODBC, so before connecting, you would need to do:</p><pre><code class="language-julia">ODBC.setunixODBC()
conn = ODBC.Connection(...)</code></pre><p>Note that the odbc driver shared libraries can be &quot;sticky&quot; with regards to changing to system configuration files. You may need to set a <code>OVERRIDE_ODBCJL_CONFIG</code> environment variable before starting <code>julia</code> and running <code>import ODBC</code> to ensure that no environment variables are changed by ODBC.jl itself. You can do this like:</p><pre><code class="language-julia">ENV[&quot;OVERRIDE_ODBCJL_CONFIG&quot;] = true
using ODBC
ODBC.setunixODBC(;ODBCSYSINI=&quot;/etc&quot;, ODBCINSTINI=&quot;odbcinst.ini&quot;, ODBCINI=&quot;/etc/odbc.ini&quot;)
conn = ODBC.Connection(...)</code></pre><h3><a class="nav-anchor" id="Executing-Queries-1" href="#Executing-Queries-1">Executing Queries</a></h3><p>To execute queries, there are two paths:</p><ul><li><code>DBInterface.execute(conn, sql, params)</code>: directly execute a SQL query and return a <code>Cursor</code> for any resultset</li><li><code>stmt = DBInterface.prepare(conn, sql); DBInterface.execute(stmt, params)</code>: first prepare a SQL statement, then execute, perhaps multiple times with different parameters</li></ul><p>Both forms of <code>DBInterface.execute</code> return a <code>Cursor</code> object that satisfies the <a href="https://juliadata.github.io/Tables.jl/stable/">Tables.jl</a>, so results can be utilized in whichever way is most convenient, like <code>DataFrame(x)</code>, <code>CSV.write(&quot;results.csv&quot;, x)</code> or materialzed as a plain <code>Matrix</code> (<code>Tables.matrix(x)</code>), <code>NamedTuple</code> (<code>Tables.columntable(x)</code>), or <code>Vector</code> of <code>NamedTuple</code> (<code>Tables.rowtable(x)</code>).</p><p>An example of executing query is:</p><pre><code class="language-julia">using DataFrames
df = DBInterface.execute(conn, &quot;SELECT id, wage FROM employees&quot;) |&gt; DataFrame
# if wage is a DecFP, maybe I want to convert to Float64 or Int64
# convert to Float64
df.wage = Float64.(df.wage)
# convert to Int64
df.wage = Int.(df.wage)</code></pre><h3><a class="nav-anchor" id="Loading-data-1" href="#Loading-data-1">Loading data</a></h3><p>ODBC.jl attempts to provide a convenient <code>ODBC.load(table, conn, table_name)</code> function for generically loading Tables.jl-compatible sources into database tables. While the ODBC spec has some utilities for even making this possible, just note that it can be tricky to do generically in practice due to differences in database requirements for <code>CREATE TABLE</code> and column type statements.</p><h2><a class="nav-anchor" id="Troubleshooting-1" href="#Troubleshooting-1">Troubleshooting</a></h2><p>Using ODBC is notoriously complex on any system/language, so here&#39;s a collection of ideas/cases that have tripped people up in the past.</p><h3><a class="nav-anchor" id="Connection-issues-1" href="#Connection-issues-1">Connection issues</a></h3><p>If you&#39;re having connection issues, try to look up the documented requirements for the specific ODBC driver you&#39;re using; in particular, try to see if a specific driver manager is required, like iODBC or unixODBC. One example is in the Microsoft-provided SQL Server ODBC driver for mac/OSX which requires unixODBC as opposed to the usual OSX default iODBC. In ODBC.jl, you can easily switch between the two by just doing <code>ODBC.setunixODBC()</code> or <code>ODBC.setiODBC()</code>.</p><h3><a class="nav-anchor" id="Query-mangling/unicode-issues-1" href="#Query-mangling/unicode-issues-1">Query mangling/unicode issues</a></h3><p>Unicode support in ODBC is notoriously messy; different driver managers supports different things manually vs. automatically, drivers might require specific encodings or be flexible for all. ODBC.jl tries to stick with the most generally accepted defaults which is using the UTF-16 encoding in unixODBC and Windows, and using UTF-32 for OSX with iODBC. Sometimes, specific drivers will have configurations or allow datasource connection parameters to alter these. We don&#39;t recommend changing to anything but the defaults, but sometimes there are defaults shipped with drivers that don&#39;t match ODBC.jl&#39;s defaults. One example is the Impala ODBC driver on linux, which is correctly built against unixODBC (default driver manager on linux), but then sets a property <code>DriverManagerEncoding=UTF-32</code> in the <code>/opt/cloudera/impalaodbc/lib/64/cloudera.impalaodbc.ini</code> file which messes things up (since ODBC.jl tries to use UTF-16). This examples shows that there may be driver-provided configuration files that make affect things that sometimes take some digging to figure out. Always try to read through the driver documentation and keep an eye out for these kinds of settings, and then don&#39;t be afraid to snoop around in the installed files to see if anything seems out of place.</p><h2><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h2><h3><a class="nav-anchor" id="DBMS-Connections-1" href="#DBMS-Connections-1">DBMS Connections</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DBInterface.connect" href="#DBInterface.connect"><code>DBInterface.connect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DBInterface.connect(ODBC.Connection, dsn_or_connectionstring; user, password, extraauth, connectionstring::Bool=false)</code></pre><p>Construct a <code>Connection</code> type by connecting to a valid ODBC Connection or by specifying a datasource name or valid connection string. 1st argument <code>dsn</code> can be either the name of a pre-defined ODBC Connection or a valid connection string. A great resource for building valid connection strings is <a href="http://www.connectionstrings.com/">http://www.connectionstrings.com/</a>. Takes optional keyword arguments <code>username</code>, <code>password</code>, and <code>extraauth</code>, which are used to specify auth parameters. <code>extraauth</code> is to allow you to pass a sensitive string to be appended verbatim to the end of the connection string, e.g. DB-specific auth token parameters.</p><p>Note that connecting will use the currently &quot;set&quot; ODBC driver manager, which by default is iODBC on OSX, unixODBC on Linux, and the system driver manager on Windows. If you experience cryptic connection errors, it&#39;s probably worth checking with your ODBC driver documentation to see if it requires a specific driver manager. For example, Microsoft-provided ODBC driver for SQL Server requires unixODBC on OSX, but by default, ODBC.jl sets the driver manager to iODBC, so before connecting, you would need to do:</p><pre><code class="language-julia">ODBC.setunixODBC()
conn = ODBC.Connection(...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L65-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.Connection" href="#ODBC.Connection"><code>ODBC.Connection</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ODBC.Connection(dsn_or_connectionstring; user, password, extraauth)</code></pre><p>Construct a <code>Connection</code> type by connecting to a valid ODBC Connection or by specifying a datasource name or valid connection string. 1st argument <code>dsn</code> can be either the name of a pre-defined ODBC Connection or a valid connection string. A great resource for building valid connection strings is <a href="http://www.connectionstrings.com/">http://www.connectionstrings.com/</a>. Takes optional keyword arguments <code>username</code>, <code>password</code>, and <code>extraauth</code>, which are used to specify auth parameters. <code>extraauth</code> is to allow you to pass a sensitive string to be appended verbatim to the end of the connection string, e.g. DB-specific auth token parameters.</p><p>Note that connecting will use the currently &quot;set&quot; ODBC driver manager, which by default is iODBC on OSX, unixODBC on Linux, and the system driver manager on Windows. If you experience cryptic connection errors, it&#39;s probably worth checking with your ODBC driver documentation to see if it requires a specific driver manager. For example, Microsoft-provided ODBC driver for SQL Server requires unixODBC on OSX, but by default, ODBC.jl sets the driver manager to iODBC, so before connecting, you would need to do:</p><pre><code class="language-julia">ODBC.setunixODBC()
conn = ODBC.Connection(...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L35-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DBInterface.close!" href="#DBInterface.close!"><code>DBInterface.close!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DBInterface.close!(conn)</code></pre><p>Close an open connection. In general, statements and open cursors will not be valid once a connection has been closed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L99-L104">source</a><div><div><pre><code class="language-none">DBInterface.close!(stmt)</code></pre><p>Close a prepared statement. Further parameter binding or execution will not be valid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L116-L120">source</a></section><h3><a class="nav-anchor" id="Query-execution-and-result-handling-1" href="#Query-execution-and-result-handling-1">Query execution and result handling</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DBInterface.prepare" href="#DBInterface.prepare"><code>DBInterface.prepare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DBInterface.prepare(conn, sql) -&gt; ODBC.Statement</code></pre><p>Prepare a query string, optionally including parameters to bind upon execution (with <code>?</code> markers). Please refer to individual dbms documentation for the exact level of parameter binding support.</p><p>The returned prepared statement can then be passed to <code>DBInterface.execute(stmt, params)</code> with <code>params</code> that will be bound before execution. This allows preparing the statement once, and re-using it many times with different parameters (or the same) efficiently.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L123-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DBInterface.execute" href="#DBInterface.execute"><code>DBInterface.execute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">DBInterface.execute(stmt, params=(); iterate_rows::Bool=false, ignore_driver_row_count::Bool=false, normalizenames::Bool=false, debug::Bool=false) -&gt; ODBC.Cursor</code></pre><p>Execute a prepare statement, binding any parameters beforehand. Returns a <code>Cursor</code> object, even if the statement is not resultset-producing (cursor will have zero rows and/or columns). The <code>Cursor</code> object satisfies the <a href="https://juliadata.github.io/Tables.jl/dev/">Tables.jl</a> interface as a source, so any valid sink can be used for inspecting results (a list of integrations is maintained <a href="https://github.com/JuliaData/Tables.jl/blob/master/INTEGRATIONS.md">here</a>).</p><p>Supported keyword arguments include:</p><ul><li><code>iterate_rows::Bool</code>: for forcing row iteration of the resultset</li><li><code>ignore_driver_row_count::Bool</code>: for ignoring the row count returned from the database driver; in some cases (Netezza), the driver may return an incorrect or &quot;prefetched&quot; number for the row count instead of the actual row count; this allows ignoring those numbers and fetching the resultset until truly exhausted</li><li><code>normalizenames::Bool</code>: normalize column names to valid Julia identifiers; this can be convenient when working with the results in, for example, a <code>DataFrame</code> where you can access columns like <code>df.col1</code></li><li><code>debug::Bool</code>: for printing additional debug information during the query/result process.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L142-L156">source</a><div><div><pre><code class="language-none">DBInterface.execute(conn, sql, params=(); iterate_rows::Bool=false, ignore_driver_row_count::Bool=false, normalizenames::Bool=false, debug::Bool=false) -&gt; ODBC.Cursor</code></pre><p>Send a query directly to connection for execution. Returns a <code>Cursor</code> object, even if the statement is not resultset-producing (cursor will have zero rows and/or columns). The <code>Cursor</code> object satisfies the <a href="https://juliadata.github.io/Tables.jl/dev/">Tables.jl</a> interface as a source, so any valid sink can be used for inspecting results (a list of integrations is maintained <a href="https://github.com/JuliaData/Tables.jl/blob/master/INTEGRATIONS.md">here</a>).</p><p>Supported keyword arguments include:</p><ul><li><code>iterate_rows::Bool</code>: for forcing row iteration of the resultset</li><li><code>ignore_driver_row_count::Bool</code>: for ignoring the row count returned from the database driver; in some cases (Netezza), the driver may return an incorrect or &quot;prefetched&quot; number for the row count instead of the actual row count; this allows ignoring those numbers and fetching the resultset until truly exhausted</li><li><code>normalizenames::Bool</code>: normalize column names to valid Julia identifiers; this can be convenient when working with the results in, for example, a <code>DataFrame</code> where you can access columns like <code>df.col1</code></li><li><code>debug::Bool</code>: for printing additional debug information during the query/result process.</li></ul><p>This is an alternative execution path to <code>DBInterface.execute</code> with a prepared statement. This method is faster/less overhead for one-time executions, but prepared statements will have more benefit for repeated executions (even with different parameters).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/dbinterface.jl#L169-L187">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DBInterface.executemultiple</code>. Check Documenter&#39;s build log for details.</p></div></div><h3><a class="nav-anchor" id="Data-loading-1" href="#Data-loading-1">Data loading</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.load" href="#ODBC.load"><code>ODBC.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.load(table, conn, name; append=true, quoteidentifiers=true, limit=typemax(Int64), createtableclause=nothing, columnsuffix=Dict(), debug=false)
table |&gt; ODBC.load(conn, name; append=true, quoteidentifiers=true, limit=typemax(Int64), createtableclause=nothing, columnsuffix=Dict(), debug=false)</code></pre><p>Attempts to take a Tables.jl source <code>table</code> and load into the database represented by <code>conn</code> with table name <code>name</code>.</p><p>It first detects the <code>Tables.Schema</code> of the table source and generates a <code>CREATE TABLE</code> statement with the appropriate column names and types. If no table name is provided, one will be autogenerated, like <code>odbcjl_xxxxx</code>. The <code>CREATE TABLE</code> clause can be provided manually by passing the <code>createtableclause</code> keyword argument, which would allow specifying a temporary table or <code>if not exists</code>. Column definitions can also be enhanced by providing arguments to <code>columnsuffix</code> as a <code>Dict</code> of  column name (given as a <code>Symbol</code>) to a string of the enhancement that will come after name and type like <code>[column name] [column type] enhancements</code>. This allows, for example, specifying the charset of a string column by doing something like <code>columnsuffix=Dict(:Name =&gt; &quot;CHARACTER SET utf8mb4&quot;)</code>.</p><p>Do note that databases vary wildly in requirements for <code>CREATE TABLE</code> and column definitions so it can be extremely difficult to load data generically. You may just need to tweak some of the provided keyword arguments, but you may also need to execute the <code>CREATE TABLE</code> and <code>INSERT</code> statements yourself. If you run into issues, you can <a href="https://github.com/JuliaDatabases/ODBC.jl/issues">open an issue</a> and we can see if there&#39;s something we can do to make it easier to use this function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/load.jl#L49-L69">source</a></section><h3><a class="nav-anchor" id="ODBC-administrative-functions-1" href="#ODBC-administrative-functions-1">ODBC administrative functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.drivers" href="#ODBC.drivers"><code>ODBC.drivers</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.drivers() -&gt; Dict</code></pre><p>List installed ODBC drivers. The primary config location for installed drivers on non-windows platforms is <code>realpath(joinpath(dirname(pathof(ODBC)), &quot;../config/odbcinst.ini&quot;))</code>, i.e. an ODBC.jl-managed location. Other system/user locations may also be checked (and are used by default on windows) by the underlying ODBC driver manager, but for the most consistent results, aim to allow ODBC.jl to manage installed drivers/datasources via <code>ODBC.addriver</code>, <code>ODBC.removedriver</code>, etc.</p><p>Note that the odbc driver shared libraries can be &quot;sticky&quot; with regards to changing to system configuration files. You may need to set a <code>OVERRIDE_ODBCJL_CONFIG</code> environment variable before starting <code>julia</code> and running <code>import ODBC</code> to ensure that no environment variables are changed by ODBC.jl itself.</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L92-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.dsns" href="#ODBC.dsns"><code>ODBC.dsns</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.dsns() -&gt; Dict</code></pre><p>List installed ODBC datasources. The primary config location for installed datasources on non-windows platforms is <code>realpath(joinpath(dirname(pathof(ODBC)), &quot;../config/odbc.ini&quot;))</code>, i.e. an ODBC.jl-managed location. Other system/user locations may also be checked (and are by default on windows) by the underlying ODBC driver manager, but for the most consistent results, aim to allow ODBC.jl to manage installed drivers/datasources via <code>ODBC.adddsn</code>, <code>ODBC.removedsn</code>, etc.</p><p>Note that the odbc driver shared libraries can be &quot;sticky&quot; with regards to changing to system configuration files. You may need to set a <code>OVERRIDE_ODBCJL_CONFIG</code> environment variable before starting <code>julia</code> and running <code>import ODBC</code> to ensure that no environment variables are changed by ODBC.jl itself.</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L113-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.adddriver" href="#ODBC.adddriver"><code>ODBC.adddriver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.adddriver(name, libpath; kw...)</code></pre><p>Install a new ODBC driver. <code>name</code> is a user-provided &quot;friendly&quot; name to identify the driver. <code>libpath</code> is the absolute path to the ODBC driver shared library. Other key-value driver properties can be provided by the <code>kw...</code> keyword arguments.</p><p>This method is provided to try and provide the simplest/easiest/most consistent setup experience for installing a new driver. Editing configuration files by hand is error-prone and it&#39;s easy to miss adding something that is required.</p><p>While ODBC.jl supports all 3 major ODBC driver managers (unixODBC, iODBC, and odbc32), be aware that most DBMS ODBC driver libraries are built against only one of the 3 and can lead to compatibility issues if a different driver manager is used. This is mainly an issue for driver libraries built against iODBC and then tried to use with unixODBC or vice-versa.</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L134-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.removedriver" href="#ODBC.removedriver"><code>ODBC.removedriver</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.removedriver(name; removedsns::Bool=true)</code></pre><p>Remove an installed ODBC driver by <code>name</code> (as returned from <code>ODBC.drivers()</code>). <code>removedsns=true</code> also removes any datasources that were specified to use the driver.</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L158-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.adddsn" href="#ODBC.adddsn"><code>ODBC.adddsn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.adddsn(name, driver; kw...)</code></pre><p>Install a new ODBC datasource. <code>name</code> is a user-provided &quot;friendly&quot; name to identify the datasource (dsn). <code>driver</code> is the &quot;friendly&quot; driver name that should be used to connect to the datasource (valid driver options can be seen from <code>ODBC.drivers()</code>). Additional connection key-value properties can be provided by the <code>kw...</code> keyword arguments.</p><p>Datasources can be connected by calling <code>DBInterface.connect(ODBC.Connection, dsn, user, pwd)</code>, where <code>dsn</code> is the friendly datasource name, <code>user</code> is the username, and <code>pwd</code> is the password.</p><p>An alternative approach to installing datasources is to generate a valid &quot;connection string&quot; that includes all connection properties in a single string passed to <code>DBInterface.connect</code>. <a href="https://www.connectionstrings.com/">www.connectionstrings.com</a> is a convenient resource that provides connection string templates for various database systems.</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L171-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.removedsn" href="#ODBC.removedsn"><code>ODBC.removedsn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.removedsn(name)</code></pre><p>Remove an installed datasource by <code>name</code> (as returned from <code>ODBC.dsns()</code>).</p><p>On windows, ODBC.jl uses the system-wide configurations for drivers and datasources. Drivers and datasources can still be added via <code>ODBC.adddriver</code>/<code>ODBC.removdriver</code> and <code>ODBC.adddsn</code>/<code>ODBC.removedsn</code>, but you must have administrator privileges in the Julia session. This is accomplished easiest by pressing CTRL then right-clicking on the terminal/Julia application and choosing &quot;Run as administrator&quot;.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L194-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODBC.setdebug" href="#ODBC.setdebug"><code>ODBC.setdebug</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ODBC.setdebug(debug::Bool=true, tracefile::String=joinpath(tempdir(), &quot;odbc.log&quot;))</code></pre><p>Turn on ODBC library call tracing. This prints debug information to <code>tracefile</code> upon every entry and exit from calls to the underlying ODBC library (unixODBC, iODBC, or odbc32). Debugging can be turned off by passing <code>false</code>.</p><p>Note that setting tracing on/off requires resetting the ODBC environment, which means any open statements/connections will be closed/invalid.</p><p>Also note that due to the persistent nature of ODBC config, setting tracing will persist acrosss Julia sessions, i.e. if you turn tracing on, then quit julia and start again tracing will still be on, and will stay on until explicitly turned off.</p><p>The iODBC driver manager supports passing <code>stderr</code> as the <code>tracefile</code>, which will print all tracing information into the julia session/repl.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDatabases/ODBC.jl/blob/c39854671a2be4dda0ca6752651a86da2ed93af3/src/ODBC.jl#L12-L28">source</a></section><footer><hr/></footer></article></body></html>
